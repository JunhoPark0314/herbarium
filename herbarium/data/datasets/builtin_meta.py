# -*- coding: utf-8 -*-
# Copyright (c) Facebook, Inc. and its affiliates.

"""
Note:
For your custom dataset, there is no need to hard-code metadata anywhere in the code.
For example, for COCO-format dataset, metadata will be obtained automatically
when calling `load_coco_json`. For other dataset, metadata may also be obtained in other ways
during loading.

However, we hard-coded metadata for a few common dataset here.
The only goal is to allow users who don't have these dataset to use pre-trained models.
Users don't have to download a COCO json (which contains metadata), in order to visualize a
COCO model (with correct class names and colors).
"""


# All coco categories, together with their nice-looking visualization colors
# It's from https://github.com/cocodataset/panopticapi/blob/master/panoptic_coco_categories.json

import json
from os import path

def _get_herb_instances_meta(metadata_json):
    # TODO: Do some validation about metadata in here
    if path.exists(metadata_json) is False:
        return None

    with open(metadata_json) as meta_file:
        return json.load(meta_file)

    thing_ids = [k["id"] for k in COCO_CATEGORIES if k["isthing"] == 1]
    thing_colors = [k["color"] for k in COCO_CATEGORIES if k["isthing"] == 1]
    assert len(thing_ids) == 80, len(thing_ids)
    # Mapping from the incontiguous COCO category id to an id in [0, 79]
    thing_dataset_id_to_contiguous_id = {k: i for i, k in enumerate(thing_ids)}
    thing_classes = [k["name"] for k in COCO_CATEGORIES if k["isthing"] == 1]
    ret = {
        "thing_dataset_id_to_contiguous_id": thing_dataset_id_to_contiguous_id,
        "thing_classes": thing_classes,
        "thing_colors": thing_colors,
    }
    return ret

def _get_cub_instances_meta(classes_txt):
    # TODO: Do some validation about metadata in here
    if path.exists(classes_txt) is False:
        return None
    
    with open(classes_txt) as classes_file:
        classes = classes_file.readlines()
        meta = {"num_classes": {"species": len(classes), "family": len(classes) // 10 }}
        return meta


def _get_builtin_metadata(dataset_name, metadata_json):
    if dataset_name == "herb":
        return _get_herb_instances_meta(metadata_json)
    if dataset_name == "cub":
        return _get_cub_instances_meta(metadata_json)

    raise KeyError("No built-in metadata for dataset {}".format(dataset_name))
